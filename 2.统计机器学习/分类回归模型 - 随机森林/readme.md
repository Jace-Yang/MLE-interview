# 随机森林



### 0x01. 简介

   随机森林就是通过集成学习的**Bagging**思想将多棵树集成的一种算法：它的基本单元就是决策树。随机森林的名称中有两个关键词，一个是“随机”，一个就是“森林”。“森林”很好理解，一棵叫做树，那么成百上千棵就可以叫做森林了，其实这也是随机森林的主要思想--集成思想的体现。“随机”的含义我们会在下面讲到。

   我们要将一个输入样本进行分类，就需要将它输入到每棵树中进行分类。将若干个弱分类器的分类结果进行投票选择，从而组成一个强分类器，这就是随机森林bagging的思想：

![img](https://pic4.zhimg.com/v2-3247edfc357e11bb9f181182506f0caf_b.png)

每棵树的按照如下规则生成：

（1）如果训练集大小为N，对于每棵树而言，随机且有放回地从训练集中的**抽取N个训练样本**（就是bootstrap sample方法, 拔靴法采样）作为该树的训练集；从这里我们可以知道：每棵树的训练集都是不同的，而且里面包含重复的训练样本。

（2）如果存在M个特征，则在每个节点分裂的时候，**从M中随机选择m个特征维度**（m << M），使用这些m个特征维度中最佳特征(最大化信息增益)来分割节点。在森林生长期间，m的值保持不变。

​    一开始我们提到的随机森林中的“随机”就是指的这里的**两个随机性**。两个随机性的引入对随机森林的分类性能至关重要。由于它们的引入，使得随机森林不容易陷入过拟合，并且具有很好得抗噪能力（比如：对缺省值不敏感）。

随机森林分类效果（错误率）与两个因素有关：

- 森林中任意两棵树的相关性：相关性越大，错误率越大；（弱分类器应该good且different）
- 森林中每棵树的分类能力：每棵树的分类能力越强，整个森林的错误率越低。（弱分类器应该good且different）

​    减小特征选择个数m，树的相关性和分类能力也会相应的降低；增大m，两者也会随之增大。所以关键问题是如何选择最优的m，这也是随机森林的一个重要参数。

### 0x02. OOB (袋外错误率)

上面我们提到，构建随机森林的关键问题就是如何选择最优的特征数m这个参数，要解决这个问题主要依据计算袋外错误率OOB error（out-of-bag error）。

随机森林有一个重要的优点就是，没有必要对它进行交叉验证或者用一个独立的测试集来获得误差的一个无偏估计。它可以在内部进行评估，也就是说在生成的过程中就可以对误差建立一个无偏估计。

​    我们知道，在构建每棵树时，我们对训练集使用了不同的bootstrap sample（随机且有放回地抽取）。所以对于每棵树而言（假设对于第k棵树），大约有1/3的训练实例没有参与第k棵树的生成，它们称为第k棵树的oob样本。而这样的采样特点就允许我们进行oob估计，它的计算方式如下：

- 对每个样本，计算它作为oob样本的树对它的分类情况（约1/3的树）；
- 然后以简单多数投票作为该样本的分类结果；
- 最后用误分个数占样本总数的比率作为随机森林的oob误分率。

​    **oob误分率是随机森林泛化误差的一个无偏估计**，它的结果**近似于**需要大量计算的k折交叉验证。这样，就可以通过比较oob误分率来选择一个最好的特征数m。

### 0x03. 随机森林参数

在`scikit-learn`中，RF的分类器是`RandomForestClassifier`，回归器是RandomForestRegressor。RF的参数也包括两部分，第一部分是Bagging框架的参数，第二部分是一棵CART决策树的参数。具体的参数参考随机森林分类器的函数原型：

```python
sklearn.ensemble.RandomForestClassifier(
        n_estimators=10, criterion='gini',
        max_depth=None,min_samples_split=2, 
        min_samples_leaf=1, min_weight_fraction_leaf=0.0,
        max_features='auto', max_leaf_nodes=None,
        min_impurity_split=1e-07,bootstrap=True,
        oob_score=False, n_jobs=1, 
        random_state=None, verbose=0,
        warm_start=False, class_weight=None)
```

#### 1. Bagging框架参数

下面来看看RF重要的Bagging框架的参数，由于`RandomForestClassifier`和`RandomForestRegressor`参数绝大部分相同，这里会将它们一起讲，不同点会指出。

1) n_estimators: 弱学习器（决策树）的个数。一般来说n_estimators太小，容易欠拟合，n_estimators太大，计算量会太大，并且n_estimators到一定的数量后，再增大n_estimators获得的模型提升会很小，所以一般选择一个适中的数值。默认是100。

2) oob_score:即是否采用袋外样本来评估模型的好坏。默认False。推荐设置为True，因为袋外分数反应了一个模型拟合后的泛化能力。

3) criterion: 即CART树做划分时对特征的评价标准。分类模型和回归模型的损失函数是不一样的。分类RF对应的CART分类树默认是基尼系数**gini**,另一个可选择的标准是信息增益(information gain)。回归RF对应的CART回归树默认是均方差mse，另一个可以选择的标准是绝对值差mae。一般来说选择默认的标准就已经很好的。

从上面可以看出, RF重要的框架参数比较少，主要需要关注的是 n_estimators，即森林中决策树的个数。

#### 2. 决策树参数

下面我们再来看RF的决策树参数:

1) RF划分时考虑的最大特征数 max_features: 就是之前提到的“在每个节点处，从M中随机选择m个特征维度”中的那个m。默认是"auto",意味着每个节点在划分时随机考虑 ![\sqrt N](https://www.zhihu.com/equation?tex=%5Csqrt%20N) 个特征；如果是"log2"意味着划分时随机考虑 ![log_2^N](https://www.zhihu.com/equation?tex=log_2%5EN)个特征；如果是整数，代表考虑的特征绝对数。如果是浮点数，代表考虑特征百分比，即考虑百分比*总特征维度数取整后的特征数。一般用默认的"auto"就可以了；如果特征数非常多，可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。

2) 决策树最大深度max_depth: 默认可以不输入，如果不输入的话，决策树在建立子树的时候不会限制子树的深度。一般来说，数据少或者特征少的时候可以不管这个值。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。

3) 内部节点再划分所需最小样本数min_samples_split: 这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再划分。默认是2。如果样本量数量级非常大，则推荐增大这个值。

4) 叶子节点最少样本数min_samples_leaf: 这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝，只保留原来的父节点。默认是1。如果样本量数量级非常大，则推荐增大这个值。

5）叶子节点最小的样本权重和min_weight_fraction_leaf：这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝，只保留原来的父节点。 默认是0，就是不考虑权重问题。如果我们有较多样本有缺失值，或者分类树样本的分布类别非常不平衡，就会引入样本权重，这时我们就要注意这个值了。

6) 最大叶子节点数max_leaf_nodes: 通过限制最大叶子节点数，可以防止过拟合，默认是"None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征非常多的话，可以加以限制，具体的值可以通过交叉验证得到。

7) 节点划分最小不纯度min_impurity_split:  这个值限制了决策树的增长，如果某节点的不纯度(基于基尼系数，均方差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。一般不推荐改动，默认值1e-7。

上面决策树参数中最重要的包括最大特征数max_features， 最大深度max_depth， 内部节点再划分所需最小样本数min_samples_split和叶子节点最少样本数min_samples_leaf。

### 0x04. 随机森林的特点

- 能够处理具有高维特征的输入样本，而且不需要降维/It can handle thousands of input variables without variable deletion；
- 能够评估各个特征在分类问题上的重要性(feature importance)
- 在生成过程中，能够获取到内部生成误差的一种无偏估计(OOB)
- 对于缺省值问题也能够获得很好得结果/It has an effective method for estimating missing data and maintains accuracy when a large proportion of the data are missing




  