# 内存机制

### 0x01. 变量与对象

变量指针指向具体对象的内存空间，取对象的值。

![img](https://images2015.cnblogs.com/blog/1113510/201707/1113510-20170703162719722-1993553654.png)

```python
a=123
b=a
print(id(a))
print(id(b))

a=456
print(id(a))
print(id(b))
```

输出：

```python
140714080403008
140714080403008
3007502017968
140714080403008
```

**引用所指判断：**通过is进行引用所指判断，is是用来判断两个引用所指的对象是否相同。

(1) int

```python
a=123
b=123
print(a is b) ### True
```

(2) string

```python
a="hello"
b="hello"
print(a is b)
```

(3) 列表

```python
a=['1','2','3']
b=['1','2','3']
print(a is b)
```

　可见，

　1、Python**缓存**了整数和短字符串，因此每个对象在内存中只存有一份，引用所指对象就是相同的，即使使用赋值语句，也**只是创造新的引用，而不是对象本身**；

2. Python没有缓存列表及其他对象，可以有多个相同的对象，可以使用赋值语句创建出新的对象。



### 0x02. 引用计数

Python中，主要通过**引用计数（Reference Counting）**进行垃圾回收。

```python
typedef struct_object {
 int ob_refcnt;
 struct_typeobject *ob_type;
} PyObject;
```

在Python中每一个对象的核心就是一个结构体PyObject，它的内部有一个引用计数器（ob_refcnt）。程序在运行的过程中会实时的更新`ob_refcnt`的值，来反映**引用当前对象的名称数量**。当某对象的引用计数值为0,那么它的内存就会被立即释放掉。

以下情况是导致引用计数加一的情况:

- 对象被创建，例如a=2
- 对象被引用，b=a
- 对象被作为参数，传入到一个函数中
- 对象作为一个元素，存储在容器中

下面的情况则会导致引用计数减一:

- 对象别名被显示销毁 del
- 对象别名被赋予新的对象
- 一个对象离开他的作用域
- 对象所在的容器被销毁或者是从容器中删除对象

我们还可以通过sys包中的getrefcount()来获取一个名称所引用的对象当前的引用计数。注意，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。

```python
sys.getrefcount(a)
```



### 0x03. 垃圾回收

当Python中的对象越来越多，占据越来越大的内存，启动垃圾回收 (garbage collection)，将没用的对象清除。

当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾。比如某个新建对象，被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。

```python
a = 1
del a
print(a)  ### error!
```

`del a`后，已经没有任何引用指向之前建立的[321,123]，该表引用计数变为0，用户不可能通过任何方式接触或者动用这个对象，当垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空。

**什么时候进行垃圾回收？**

垃圾回收时，Python不能进行其它的任务，频繁的垃圾回收将大大降低Python的工作效率，所以，Python只会在特定条件下，自动启动垃圾回收（垃圾对象少就没必要回收）。实际上，Python 通过**“分代回收”(Generational Collection)** 以空间换时间的方法提高垃圾回收效率。

分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的**生存周期比较短**；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：**对象存在时间越长，越可能不是垃圾，应该越少去收集**。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。

python给对象定义了三种世代(0,1,2),每一个新生对象是第0代，如果它在一轮gc扫描中活了下来，那么它将被移至第一代,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至第二代，在那里它被扫描的次数将会更少。

gc的扫描在什么时候会被触发呢?答案是当某一世代中**被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发gc对某一世代的扫描**。值得注意的是当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。

当然，也可以**手动**启动垃圾回收：`gc.collect()`

### 0x04. 内存池

Python引用了一个内存池(memory pool)机制，用于对**小块内存**的申请和释放管理。

内存池（memory pool）的概念：当创建大量消耗**小内存**(<256kb)的对象时，频繁调用new/malloc会导致大量的**内存碎片**，致使效率降低。内存池的概念就是**预先在内存中申请一定数量的，大小相等的内存块**留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。
当分配内存大于256kb，则会直接执行 new/malloc 的行为来申请新的内存空间。
