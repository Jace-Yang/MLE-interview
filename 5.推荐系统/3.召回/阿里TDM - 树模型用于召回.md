# 阿里TDM - 树模型用于召回

Learning Tree-based Deep Model for Recommendation Systems

### 一、论文背景

1、近年来推荐系统发展迅速，从基于启发式规则方法（代表算法Item-CF），再到基于DNN的深层向量化检索方法（Youtube DNN）。但是目前向量化检索方法也存在一定的缺陷，利用**内积**形式来评价用户对物品的偏好程度本身的表达能力有限。如何利用更加精准先进的评价模型来衡量用户对物品偏好程度成为了一个关键点。

总的来说，TDM主要用来解决从海量数据集下（甚至是全库数据）下高效准确的**召回**用户感兴趣的Top-K商品的问题

### 二、现有框架存在的问题及创新点

1、在Item-CF算法中，倒排索引根据Item之间的相似度建立，检索的时候则是根据用户历史行为对Item进行排序，排序的时候会对Item进行打分（基于规则），整个过程都是基于规则的，**不存在学习的过程**，排序能力受限。

2、向量化检错过程中，通常是学习得到用户和Item两者的embedding向量，然后利用向量内积表示用户对Item的偏好程度，这种**内积**表征偏好的方式表达能力有限。



### **三、TDM模型**

通常大规模搜索、广告、推荐系统的召回模块包括以下几个部分：**索引**（用于高效检索）、**评分规则**（给出用户对于商品的偏好程度）、**检索算法**（根据评分规则，利用索引筛选出合适的商品集）。TDM的整体模型如下图所示：

![img](https://pic4.zhimg.com/80/v2-c7a1714f03e5a0f2dbd94d78db1e54f7_1440w.jpg)

其中索引的构建方式就是绿色方框中的**树形**结构，评分规则就是红框中的复杂DNN网络（用于输出用户对树节点的偏好程度，其中叶子节点表征每一个商品，非叶子节点是对商品的一种抽象化表征，可以不具有具体的物理意义），检索算法是beam search算法。

基于上述系统架构，整个召回过程可以概括为如下几个部分：

1、文中指出绿色框中树形结构的**叶子**节点表征的是具体的每一个商品，具有明确的物理意义（如叶子节点8代表粗跟高跟鞋，叶子节点9代表细跟高跟鞋），而非叶子节点则是对商品的进一步抽象化表征，是一种更粗粒度的表征（如节点4可能代表的是高跟鞋，当然节点4可能也不具备明确的屋里意义），总之父节点相较于子节点来说是一种更粗粒度的表征。

2、在这种树形索引结构的基础上如何保证检索的高效性呢，文中指出为高效的检索出Top-K的商品，该树形结构实际上是一种类似于最大堆的树结构，并且**对于用户u来说，对l层非叶子节点n的偏好概率**表征如下式：

![img](https://pic1.zhimg.com/80/v2-8ebbfb6037db2cedc564ee499b378548_1440w.png)

其中p(n|u)表示的就是用户u对j层节点n感兴趣的概率，α(j)是归一化因子，从上式可以得出，用户u对j层节点n感兴趣的概率，等于用户**对该节点的子节点的偏好概率的最大值**（上述过程就是文中所述的兴趣建模）。所以我们如果最终需要检索出Top-K个商品，只需要自顶向下的在每一层检索出当前层的Top-K节点，但是当前层的检索集是上一层Top-K节点的子节点，从这些子节点中检索出当前层的Top-K节点。具体举例来说，如图中绿色框的树形结构，最终要检索Top-2商品，那么从树的第二层开始，a）我们选取第二层的Top-K节点(2和3)；b)在第三层的时候，根据上述公式，我们可以知道该层的Top-2的一定位于节点2和节点3的子节点中，所以我们只需要从4、5、6、7节点中检索Top-2，假设检索结果是节点5和6；c)在第四层中我们检索该层的Top-2，根据公式可以知道该层的Top-2节点一定存在于节点5和6的叶子节点中，所以只需要从叶子节点10、11、12、13中检索出最终的Top-2节点，上述检索过程即为**Beam Search**方式。

3、在了解TDM是如何实现检索过程之后，还需要解决的问题就是如何对每层选取Top-K节点，具体做法就如上图中的红色框的部分，该部分的输入包括用户的历史行为特征以及节点的Embedding特征，在对每一层选取Top-K的时候，需要将这一层的每一个节点输入左侧模型中得到相应的**预测分数**，最终根据分数来取Top，文中指出TDM可以任意复杂的排序模型也得益于这种系统架构。

4、模型训练之前先需要构建正负样本。每层的正样本就是点击商品对应叶子节点的祖先；每层的负样本就是随机选取的负样本。得到训练样本之后，相应的损失函数如下所示：

![img](https://pic2.zhimg.com/80/v2-602d42670ed659caae66697d7f64f9ed_1440w.jpg)

在给定训练样本和损失函数的基础上，接下来需要做的就是进行模型的训练，整个系统包括**树形索引结构**和**复杂DNN**两部分，文中采用的是联合训练的方式，整体联合训练的方式如下：

a) **初始化一棵树**。这个树的结构怎么初始化呢？首先借助商品的**类别**信息进行排序，将相同类别的商品放到一起，然后递归的将同类别中的商品等量的分到两个子类中（为了得到平衡的二叉树），直到集合中只包含一项，利用这种自顶向下的方式来初始化一棵树。然后基于该树训练深层模型直到其收敛，训练结束之后可以得到每个树节点的embedding向量

b)基于训练好的深层模型（包括叶子节点的embedding部分），利用节点的Embedding重新构建一颗新的树。这个新的树是用K-means来构建的。每次都进行K = 2的二分类，直到生成一个二叉树。

c) 最后基于这颗新生成的树，重新训练深层网络。



### 四、总结

1、本文提出的TDM模型结构主要解决大规模样本下高效检索Top-K候选商品的问题（大规模样本下的**召回**问题），类似最大堆的树形索引结构有效降低全库索引的复杂度。

2、基于文章给出的树形检索结构，TDM**支持任意复杂的评分模型**，这给进一步**提升系统的召回质量**提供了可能。

3、基于树形索引和复杂排序模型的联合训练问题还有待进一步优化，而阿里妈妈在今年针对这部分的工作也取得了一定的进展，并且最新的研究成果也已经发表（Joint Optimization of Tree-based Index and Deep Model for Recommender Systems），接下来我也会该文章进行解读

