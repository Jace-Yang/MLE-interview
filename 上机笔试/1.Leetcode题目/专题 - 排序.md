# 专题 - 排序

#### 1. 快排

```python
import random

class Solution:
    def sortArray(self, nums):
        self.quick_sort(nums,0,len(nums)-1)  ##左闭右闭
        return nums
        
    def quick_sort(self,arr,low,high):
        if(low > high):
            return
        mid = self.find_partition(arr, low,high) ##构造轴点，此时左边都<轴点，右边都>轴点
        self.quick_sort(arr, low,mid - 1) ## 排序左边
        self.quick_sort(arr, mid+1,high) ##排序右边

    def find_partition(self,arr, low, high):
        pivot_pos = random.randint(low, high)  ##随机选轴点
        arr[pivot_pos],arr[high] = arr[high],arr[pivot_pos] ##和最后一位交换
        pivot = arr[high]
        split = low-1
        for j in range(low,high):
            if (arr[j] < pivot):
                arr[split+1],arr[j] = arr[j],arr[split+1]
                split+=1
        arr[split+1],arr[high] = arr[high],arr[split+1]

        return split + 1

```

培养一个轴点：

![img](https://pic1.zhimg.com/80/v2-2b70124e17ea9fea9eda1e9bfb745a58_1440w.jpg)

具体的方法：

1. 首先，选择最后一个元素--pivot = A[right]作为我们要培养的轴点
2. 一个指针j从low遍历到high-1；另外维护一个split，使得[low,split]的值都<轴点，[split+1,high]的值都>轴点

![img](https://pic1.zhimg.com/80/v2-92d87d44c985b2f9589b7626f58c6ba0_1440w.jpg)

- 在考察j时，如果arr[j]>=pivot, 不用动；如果arr[j] < pivot, 交换arr[split+1]和arr[j], split++

3. 最终，交换arr[split+1]和arr[right], 返回split+1



【注】如果不用随机选轴点，最坏情况（数组已经接近有序）时，复杂度O(n^2). 但是平均情况还是O(nlogn). 为了能够达到这个“期望”复杂度，我们需要随机选择轴点才行。

#### 2. 冒泡排序

```python
def bubble_sort(arr,length):
    for i in range(0,length-1): ##迭代length-1次
        for j in range(0,length-i-1): ##每次都把最大的放到最后面
            if(arr[j+1]<arr[j]):
                tmp = arr[j+1]
                arr[j+1] = arr[j]
                arr[j] = tmp
    return arr
```

最坏情况：输入序列完全反序，复杂度O(n^2), 

最好情况：输入序列业已顺序，经过一趟扫描，即确认有序，并随即退出。复杂度O(n). 

#### 2. 一些自带的排序工具

`intervals.sort(key=lambda x: x[0])   `