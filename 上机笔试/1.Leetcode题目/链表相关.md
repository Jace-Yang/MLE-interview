# 链表相关

#### Leetcode 206 反转链表

题目描述：给你单链表的头节点 head，请你反转链表，并返回反转后的链表。

![img](https://lh4.googleusercontent.com/joKJtKnI6-wBmfeWRFX9D8kswJe-SSYkoPmf8o32oZljQh9v3Dp96V_MST5FYDgFZmjiKpgLVN2oG0wJh9osiSX6TUFirZw-2W40S44jWvCEnCGkyG_n-C3YoDLT_ulw9Oa5Xsyt)

示例：

输入：head = [1,2,3,4,5]

输出：[5,4,3,2,1]

思路：

只需要将每个节点的next指针修改成指向前面即可。所以设置prev和curr, 每次都将curr的next指针指向prev。

![img](https://lh3.googleusercontent.com/Cinxd1PU1MMUSUKhgha8X8kdHMM4Hn7XjKdIwqhfRReOi0-19s3j-3p0hnNu4bwdZ2C20jD4zjpd5_1t4eGqxX7UH1EjO4vxZjIgua8Nrnc9qlO3zyPVEi9uDAElnvYvGE3NbmiQ)



```python
ListNode* reverse_list(ListNode* head){ //迭代方法反转单链表
        ListNode* prev = NULL;
        ListNode* curr = head;
        while(curr){
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;//return now是错的！！因为now在循环结束之后一定是null啊
    }
```



### 21. 合并两个有序链表

直接改变节点之间的连接关系即可。

```python
# Definition for singly-linked list.            
                    
class Solution:                                 
    def mergeTwoLists(self, list1, list2):      
        tmp1 = list1                            
        tmp2 = list2                            
        head = ListNode(-1)  ##dummy head                   
        tmp = head                              
        while(tmp1 and tmp2):                   
            if tmp1.val < tmp2.val:             
                tmp.next = tmp1                 
                tmp1 = tmp1.next                
                tmp = tmp.next                  
            else:                               
                tmp.next = tmp2                 
                tmp2 = tmp2.next                
                tmp = tmp.next                  
        while(tmp1):                            
            tmp.next = tmp1                     
            tmp1 = tmp1.next                    
            tmp = tmp.next                      
        while(tmp2):                            
            tmp.next = tmp2                     
            tmp2 = tmp2.next                    
            tmp = tmp.next                      
        return head.next                           
```



### 23. 合并K个有序链表 [hard]

二分递归+合并两个有序链表

```python
# Definition for singly-linked list.
class ListNode:
     def __init__(self, val=0, next=None):
         self.val = val
         self.next = next
         
class Solution:
    def mergeKLists(self, lists):   ###二分法合并
        n = len(lists)
        if n == 0:
            return None
        if n == 1:    ##不用合并了
            return lists[0]
        return self.DFS(lists,0,n-1)
        
    def DFS(self,lists,begin,end):
        if begin == end:
            return lists[begin]
        if begin > end:
            return []
        middle = int((begin+end)/2)
        leftpart = self.DFS(lists,begin,middle)
        rightpart = self.DFS(lists,middle+1,end)
        return self.mergeTwoLists(leftpart,rightpart)
        
        
        
    def mergeTwoLists(self, list1, list2):  ##合并两个有序链表    
        tmp1 = list1                            
        tmp2 = list2                            
        head = ListNode(-1)  ##dummy head                   
        tmp = head                              
        while(tmp1 and tmp2):                   
            if tmp1.val < tmp2.val:             
                tmp.next = tmp1                 
                tmp1 = tmp1.next                
                tmp = tmp.next                  
            else:                               
                tmp.next = tmp2                 
                tmp2 = tmp2.next                
                tmp = tmp.next                  
        while(tmp1):                            
            tmp.next = tmp1                     
            tmp1 = tmp1.next                    
            tmp = tmp.next                      
        while(tmp2):                            
            tmp.next = tmp2                     
            tmp2 = tmp2.next                    
            tmp = tmp.next                      
        return head.next                           
```



### 25. K个一组翻转链表 [hard]

递归翻转，前翻转前K个，然后再翻转后面的。

```python
# Definition for singly-linked list.
class ListNode:
     def __init__(self, val=0, next=None):
         self.val = val
         self.next = next

class Solution:
    def reverseKGroup(self, head, k: int):
        if head == None:
            return None
        tmp = head
        can = True
        for i in range(k-1):
            if tmp.next:
                tmp = tmp.next
            else:
                can = False
                break
        if not can:     ##不够翻转，则直接返回head
            return head
            
        next_head = tmp.next
        tmp.next = None
        head = self.reverse_list(head)
        tmp = head
        while(tmp.next):
            tmp = tmp.next
        tmp.next = self.reverseKGroup(next_head,k)
        return head


    def reverse_list(self,head):  ##翻转链表
        prev = None
        curr = head
        while(curr):
            next = curr.next
            curr.next = prev
            prev = curr
            curr = next
        return prev
```





### 141. 环形链表 [easy]

判断链表里是否有环。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

就是【快慢指针】，一旦相遇则有环。

```python
# Definition for singly-linked list.
class ListNode:
     def __init__(self, x):
         self.val = x
         self.next = None  
             
class Solution:      
    def hasCycle(self, head) -> bool:
        if head == None or head.next == None:  ##平凡情况
            return False
        slow = head
        fast = head.next  
        while(slow and fast and fast.next):
            if slow == fast and slow is not None:  ###有交点
                return True
                break
            if slow == None or fast == None: ##无交点
                return False
                break
            slow = slow.next
            fast = fast.next.next
```



【易错点】

- 快指针fast一开始需要指向`head.next`,而不是`head`
- while的条件是`slow and fast and fast.next`, 不要忘记写`fast`,否则如果fast = NULL，会报错



### 160. 相交链表

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

图示两个链表在节点 c1 开始相交：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)



两个指针，如果为Null则指向对方的头，如果两者相交，则必能遇上；如果不相交，则一定能够同时指向NULL。

```python
# Definition for singly-linked list.
class ListNode:
     def __init__(self, x):
         self.val = x
         self.next = None

class Solution:
    def getIntersectionNode(self, headA, headB):
        if not headA or not headB:
            return None
        pA = headA
        pB = headB
        
        while(True): ##一定能够终止，所以可以直接写死循环！！
            if pA == pB and pA != None: ##交上了
                return pA
            
            if not pA: ##对方的头
                pA = headB
            else:
                pA = pA.next
                
            if not pB: ##对方的头
                pB = headA
            else:
                pB = pB.next
                
            if pA == pB and pA!=None:
                return pA
            
            if pA == pB and pA == None: ##都是NULL
                print("false")
                return None
```

