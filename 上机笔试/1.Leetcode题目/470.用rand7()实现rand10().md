# 用rand7()实现rand10()



重要的是保证1-10这十个数字**等概率**的出现。一个想法是用两个rand7()相乘，得到相乘矩阵：
​        1	2	3	4	5      6	7
1	1	2	3	4	5	6	7
2	2	4	6	8	10	12	14
3	3	6	9	12	15	18	21
4	4	8	12	16	20	24	28
5	5	10	15	20	25	30	35
6	6	12	18	24	30	36	42
7	7	14	21	28	35	42	49

这个“棋盘”中每个格点出现的概率都是1/49. 那么，每个数字出现的概率为：

![img](https://pic1.zhimg.com/80/v2-89e4b704656dcde8d2233f5063b19ead_1440w.png)

我们可以从中挑选 10个等概率的数即可. 例如[2,3,5,8,14,15,18,20,21,24]出现的概率都是2/49。

```python
class Solution:
    def rand10(self):
        """
        :rtype: int
        """
        accept_num = [2,3,5,8,14,15,18,20,21,24]
        seven_to_ten = {}
        for i in range(len(accept_num)):
            seven_to_ten[accept_num[i]] = i+1 ##构造accept_num->[1~10]的哈希映射
        
        while True:
            num = rand7()*rand7()
            if num in accept_num: ##是这些数之一
                return seven_to_ten[num]
```

为了尽量减少rand7()的调用，我们需要增加随机数被accept的概率。上面这种方法，只有随机数落在[2,3,5,8,14,15,18,20,21,24]才会被accept，效率很低。所以，可以把两个rand7()看成一个“棋盘”，生成1~49，然后按行按列写入1-10.

![微信图片_20210905012406.jpg](https://pic.leetcode-cn.com/1630776258-UNMORj-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210905012406.jpg)

每个格点对应的数字为`(i-1)*7+j`, 模10+1之后即得到1~10的数字。

这样，49个数字中有40个都会被接受，每次接受的概率为40/49. 如果一直随机下去，直到接受为止，随机的次数的期望是什么呢？其实，这是一个p = 40/49的几何分布，期望次数为1/p = 49/40. 

