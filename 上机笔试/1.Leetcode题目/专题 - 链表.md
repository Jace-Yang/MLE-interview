# 链表相关

#### Leetcode 206 反转链表

题目描述：给你单链表的头节点 head，请你反转链表，并返回反转后的链表。

![img](https://lh4.googleusercontent.com/joKJtKnI6-wBmfeWRFX9D8kswJe-SSYkoPmf8o32oZljQh9v3Dp96V_MST5FYDgFZmjiKpgLVN2oG0wJh9osiSX6TUFirZw-2W40S44jWvCEnCGkyG_n-C3YoDLT_ulw9Oa5Xsyt)

示例：

输入：head = [1,2,3,4,5]

输出：[5,4,3,2,1]

思路：

只需要将每个节点的next指针修改成指向前面即可。所以设置prev和curr, 每次都将curr的next指针指向prev。

![img](https://lh3.googleusercontent.com/Cinxd1PU1MMUSUKhgha8X8kdHMM4Hn7XjKdIwqhfRReOi0-19s3j-3p0hnNu4bwdZ2C20jD4zjpd5_1t4eGqxX7UH1EjO4vxZjIgua8Nrnc9qlO3zyPVEi9uDAElnvYvGE3NbmiQ)



```python
ListNode* reverse_list(ListNode* head){ //迭代方法反转单链表
        ListNode* prev = NULL;
        ListNode* curr = head;
        while(curr){
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;//return now是错的！！因为now在循环结束之后一定是null啊
    }
```



#### 92. 反转链表II

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

```python
# Definition for singly-linked list.
class ListNode:
     def __init__(self, val=0, next=None):
         self.val = val
         self.next = next
class Solution:
    def reverseBetween(self, head, left, right):
        head0 = ListNode(-1)
        head0.next = head
        left_ptr = head0
        right_ptr = head0
        for i in range(left-1):
            left_ptr = left_ptr.next
        for i in range(right):
            right_ptr = right_ptr.next

        reverse_head = left_ptr.next
        left_ptr.next = None
        right_remain = right_ptr.next
        right_ptr.next = None
        
        reverse_head_ = self.reverse_list(reverse_head)
        left_ptr.next = reverse_head_
        
        tmp = reverse_head_
        while(tmp.next):
            tmp = tmp.next
        tmp.next = right_remain
        return head0.next

    def reverse_list(self,head):
        prev = None
        curr = head
        while curr:
            curr_next = curr.next
            curr.next = prev
            prev = curr
            curr = curr_next
        return prev
```

【总结】在链表中，应该善用dummy head。



#### 21. 合并两个有序链表[easy]

直接改变节点之间的连接关系即可。

```python
# Definition for singly-linked list.            
                    
class Solution:                                 
    def mergeTwoLists(self, list1, list2):      
        tmp1 = list1                            
        tmp2 = list2                            
        head = ListNode(-1)  ##dummy head                   
        tmp = head                              
        while(tmp1 and tmp2):                   
            if tmp1.val < tmp2.val:             
                tmp.next = tmp1                 
                tmp1 = tmp1.next                
                tmp = tmp.next                  
            else:                               
                tmp.next = tmp2                 
                tmp2 = tmp2.next                
                tmp = tmp.next                  
        while(tmp1):                            
            tmp.next = tmp1                     
            tmp1 = tmp1.next                    
            tmp = tmp.next                      
        while(tmp2):                            
            tmp.next = tmp2                     
            tmp2 = tmp2.next                    
            tmp = tmp.next                      
        return head.next                           
```



### 23. 合并K个有序链表 [hard]

二分递归+合并两个有序链表

```python
# Definition for singly-linked list.
class ListNode:
     def __init__(self, val=0, next=None):
         self.val = val
         self.next = next
         
class Solution:
    def mergeKLists(self, lists):   ###二分法合并
        n = len(lists)
        if n == 0:
            return None
        if n == 1:    ##不用合并了
            return lists[0]
        return self.DFS(lists,0,n-1)
        
    def DFS(self,lists,begin,end):
        if begin == end:
            return lists[begin]
        if begin > end:
            return []
        middle = int((begin+end)/2)
        leftpart = self.DFS(lists,begin,middle)
        rightpart = self.DFS(lists,middle+1,end)
        return self.mergeTwoLists(leftpart,rightpart)
        
        
        
    def mergeTwoLists(self, list1, list2):  ##合并两个有序链表    
        tmp1 = list1                            
        tmp2 = list2                            
        head = ListNode(-1)  ##dummy head                   
        tmp = head                              
        while(tmp1 and tmp2):                   
            if tmp1.val < tmp2.val:             
                tmp.next = tmp1                 
                tmp1 = tmp1.next                
                tmp = tmp.next                  
            else:                               
                tmp.next = tmp2                 
                tmp2 = tmp2.next                
                tmp = tmp.next                  
        while(tmp1):                            
            tmp.next = tmp1                     
            tmp1 = tmp1.next                    
            tmp = tmp.next                      
        while(tmp2):                            
            tmp.next = tmp2                     
            tmp2 = tmp2.next                    
            tmp = tmp.next                      
        return head.next                           
```



### 25. K个一组翻转链表 [hard]

递归翻转，前翻转前K个，然后再翻转后面的。

```python
# Definition for singly-linked list.
class ListNode:
     def __init__(self, val=0, next=None):
         self.val = val
         self.next = next

class Solution:
    def reverseKGroup(self, head, k: int):
        if head == None:
            return None
        tmp = head
        can = True
        for i in range(k-1):
            if tmp.next:
                tmp = tmp.next
            else:
                can = False
                break
        if not can:     ##不够翻转，则直接返回head
            return head
            
        next_head = tmp.next
        tmp.next = None
        head = self.reverse_list(head)
        tmp = head
        while(tmp.next):
            tmp = tmp.next
        tmp.next = self.reverseKGroup(next_head,k)
        return head


    def reverse_list(self,head):  ##翻转链表
        prev = None
        curr = head
        while(curr):
            next = curr.next
            curr.next = prev
            prev = curr
            curr = next
        return prev
```





#### 141. 环形链表 [easy]

判断链表里是否有环。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

就是【快慢指针】，一旦相遇则有环。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# Definition for singly-linked list.
class ListNode:
     def __init__(self, x):
         self.val = x
         self.next = None  
         
         
class Solution:      
    def hasCycle(self, head) -> bool:
        if head == None or head.next == None:
            return False
        slow = head
        fast = head
        while(slow and fast and fast.next):
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
```



【易错点】

- while的条件是`slow and fast and fast.next`, 不要忘记写`fast`,否则如果fast = NULL，会报错

#### 142. 环形链表的入口节点

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

![img](https://lh3.googleusercontent.com/17wiZ2Us_oj7E599NAbOiXn3x4oqhF50rD0Z36osBpvZXvcXt9F8mtVUwoLeNugJJ2WKrGpoW6UWtiTbJK8lCPkVy8Cj_OadwsL4FG8R6JwUCbbGVEhfEoqaI_BwM4v6qfizaX2M)

在Z处相遇，则快指针走了a+(b+c)*n+b; 慢指针走了a+b. 由于快指针速度是慢指针的两倍，所以有：

2a+2b = a+(b+c)*n+b. 那么，有：a+b = (b+c)\*n ,即：a = (b+c)\*n-b

因此让两个指针分别**从起始点X和相遇点Z以相同速度前进**，两个指针再次相遇的位置即为环的入口节点Y。

```
class Solution { public:     
    ListNode* detectCycle(ListNode* pHead) {
        ListNode* fast = pHead;
        ListNode* slow = pHead;
        while(fast && slow && fast->next){
            fast = fast->next->next;             
            slow = slow->next;             
            if(fast == slow){//有环                 
                ListNode* p1 = pHead;                 
                ListNode* p2 = fast;                 
                while(p1 && p2){                     
                    if(p1 == p2)                         
                        return p1;                     
                    p1 = p1->next;                     
                    p2 = p2->next;                     
                    if(p1 == p2)                         
                        return p1;                 
                }                         
           }         
        }         
        return NULL; //没有环     
        } 
};
```



#### 160. 相交链表

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

图示两个链表在节点 c1 开始相交：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)



两个指针，如果为Null则指向对方的头，如果两者相交，则必能遇上；如果不相交，则一定能够同时指向NULL。

```python
# Definition for singly-linked list.
class ListNode:
     def __init__(self, x):
         self.val = x
         self.next = None

class Solution:
    def getIntersectionNode(self, headA, headB):
        if not headA or not headB:
            return None
        pA = headA
        pB = headB
        
        while(True): ##一定能够终止，所以可以直接写死循环！！
            if pA == pB and pA != None: ##交上了
                return pA
            
            if not pA: ##对方的头
                pA = headB
            else:
                pA = pA.next
                
            if not pB: ##对方的头
                pB = headA
            else:
                pB = pB.next
                
            if pA == pB and pA!=None:
                return pA
            
            if pA == pB and pA == None: ##都是NULL
                print("false")
                return None
```

