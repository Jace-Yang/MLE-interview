# 高级搜索树

### 1. Splay伸展树

##### 1.1 局部性

伸展树的出发点是这样的：考虑到局部性原理（刚被访问的内容下次可能仍会被访问，刚刚访问的节点**附近**的节点可能很快被访问），为了使整个查找时间更小，被查频率高的那些节点应当经常处于靠近树根的位置。这样，很容易得想到以下这个方案：每次查找节点之后，把被查找的节点**移到树根**，这种自调整形式的二叉查找树就是伸展树。

##### 1.2 逐层伸展

容易想到的方法就是，每次节点v一旦被访问，就将其”推送“至根。具体做法是对v的父节点做zig/zag：

![img](https://pic4.zhimg.com/v2-724d2732bf743cb11d413dc35f60ee5f_b.jpg)



但是，伸展过程的效率最坏会是O(n)的。例如如下这种情况，对于一个”倒序“排列的搜索树，按照[1,2,3,4,5]的顺序来访问，就会出现分摊O(n)的时间复杂度。

##### 1.3 双层伸展

所以，一种改进方法是**双层伸展** 。其方法就是反复考察**祖孙三代**，根据它们的相对位置，经过**两次旋转**，使v上升两层，成为子树根。

对于节点v按中序遍历次序居中的情况，若想要让它成为根，只有一种姿势(zig-zag/zag-zig):

![img](https://pic4.zhimg.com/v2-04dc1d096c349da21801f0fdbba16f97_b.jpg)

对于中序遍历不居中的情况，有两种可能的姿势：先转父亲还是先转祖父：

![img](https://pic3.zhimg.com/v2-f7bd458fbdf64d3d624fc0adf61ffb4e_b.jpg)

节点访问之后，对应路径长度立刻折半。这样，伸展操作分摊仅需O(logn)时间。

![img](https://pic2.zhimg.com/v2-c1fac7b1ee4312b64d8e96f7f1b50dad_b.jpg)

##### 1.4 查找、插入、删除

查找：就是常规的搜索树查找+splay伸展移动到根。

插入：

![img](https://pic4.zhimg.com/v2-c708bbdf9b9a1a00523b329c8afe52af_b.jpg)

把插入位置**附近**的节点移动到根附近，也是为了局部性。

删除：

![img](https://pic1.zhimg.com/v2-e7e782186a3d84f04bb4ce9ed58444b0_b.jpg)



分摊复杂度都为O(logn). 局部性强、**缓存命中率高**的时候，效率甚至可以更高。



### 2. B-树









