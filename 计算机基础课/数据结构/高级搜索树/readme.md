# 高级平衡搜索树

### 1. Splay伸展树

##### 1.1 局部性

伸展树的出发点是这样的：考虑到局部性原理（刚被访问的内容下次可能仍会被访问，刚刚访问的节点**附近**的节点可能很快被访问），为了使整个查找时间更小，被查频率高的那些节点应当经常处于靠近树根的位置。这样，很容易得想到以下这个方案：每次查找节点之后，把被查找的节点**移到树根**，这种自调整形式的二叉查找树就是伸展树。

##### 1.2 逐层伸展

容易想到的方法就是，每次节点v一旦被访问，就将其”推送“至根。具体做法是对v的父节点做zig/zag：

![img](https://pic4.zhimg.com/v2-724d2732bf743cb11d413dc35f60ee5f_b.jpg)



但是，伸展过程的效率最坏会是O(n)的。例如如下这种情况，对于一个”倒序“排列的搜索树，按照[1,2,3,4,5]的顺序来访问，就会出现分摊O(n)的时间复杂度。

##### 1.3 双层伸展

所以，一种改进方法是**双层伸展** 。其方法就是反复考察**祖孙三代**，根据它们的相对位置，经过**两次旋转**，使v上升两层，成为子树根。

对于节点v按中序遍历次序居中的情况，若想要让它成为根，只有一种姿势(zig-zag/zag-zig):

![img](https://pic4.zhimg.com/v2-04dc1d096c349da21801f0fdbba16f97_b.jpg)

对于中序遍历不居中的情况，有两种可能的姿势：先转父亲还是先转祖父：

![img](https://pic3.zhimg.com/v2-f7bd458fbdf64d3d624fc0adf61ffb4e_b.jpg)

节点访问之后，对应路径长度立刻折半。这样，伸展操作分摊仅需O(logn)时间。

![img](https://pic2.zhimg.com/v2-c1fac7b1ee4312b64d8e96f7f1b50dad_b.jpg)

##### 1.4 查找、插入、删除

查找：就是常规的搜索树查找+splay伸展移动到根。

插入：

![img](https://pic4.zhimg.com/v2-c708bbdf9b9a1a00523b329c8afe52af_b.jpg)

把插入位置**附近**的节点移动到根附近，也是为了局部性。

删除：

![img](https://pic1.zhimg.com/v2-e7e782186a3d84f04bb4ce9ed58444b0_b.jpg)



分摊复杂度都为O(logn). 局部性强、**缓存命中率高**的时候，效率甚至可以更高。



### 2. B-树

#### 2.1 多级存储系统

计算机的存储系统是分级组织的，磁盘 > 内存RAM > CPU寄存器。

**事实1：**若访问内存需要一秒，则访问一次外存需要一天！所以，为了避免一次外存访问，我们宁可访问内存10次、100次...

**事实2：**从磁盘中读写1B，与读写1KB几乎一样快。这是因为访问的时候是以页、块为单位访问。这样，单位字节的平均访问时间大大缩短。

#### 2.2 B-树

B树其实就是把二叉搜索树的**d代合并**成一个超级节点：共有 m = 2^d 路，m-1个关键码。逻辑上和BBST完全等价。那么，B树的意义何在？

![img](https://pic4.zhimg.com/v2-f83c7986b22afa7b9edcd36665455e23_b.jpg)


  实际上，B树的意义在于可以减少外部查找、降低I/O次数。充分利用外存**批量访问**的特点，每下降一层，都读入一组关键码。目前数据库系统一般用m = 200~300。例如，若有1G个记录，使用AVL树每次需要有 $log_2 10^9 \approx 30$个操作；若B树取m = 256, 则每次查找只需要$log_{256}{10^9} \leq 4$次I/O。有的时候常数项的优化也是很重要的哦！毕竟，四年读完大学尚可接受，如果让你读28年大学呢...?

B树的**外部节点**深度统一相等，约定以此深度来作为树高h。叶子节点深度也统一相等，为h-1:

![img](https://pic1.zhimg.com/v2-a4a3763af8effa32d6a0be90f8fa4a14_b.jpg)

m阶B树指的是每个内部节点（除了根）的**分支数**在  ![\lceil m/2 \rceil ](https://www.zhihu.com/equation?tex=%5Clceil%20m%2F2%20%5Crceil%20)  和 m之间的B树（根节点分支数为[2,m]）。例如(3,5)-树、(9,18)-树。每个内部节点的关键码数为m-1.

```c++
struct BTNode{
    BTNode * Parent; //父
    vector<int> keys; //内部节点的数值向量
    vector<BTNode*> children; //孩子向量（长度总比key多1）
}
```



#### 2.3 查找、插入、删除

##### 2.3.1 查找

忽略内存中的查找，运行时间主要取决于I/O次数，故运行时间 = O(logn)

##### 2.3.2 插入

插入之后，有可能发生上溢，关键码上升一层，并以此为界分裂为左、右孩子：

![img](https://pic2.zhimg.com/v2-b7729bc28edbb75d1b6292e45e917af5_b.jpg)

上溢可能持续发生，并逐层向上传播。如果抵达树根，那么新生的树根就只有两个分支。

##### 2.3.3 删除

可能发生下溢，这时候需要根据兄弟节点的关键码个数决定解决方法。如果兄弟节点的关键码个数足够，则父亲从兄弟“借”一个，然后父亲来贴补下溢的空缺。

如果兄弟节点的关键码个数也不够，那么只能让父亲来“拼合”两个兄弟：


![img](https://pic3.zhimg.com/v2-2e9984a4d9a7d0db97ad96116dc0b172_b.jpg)





### 3. 红黑树

红黑树是一种特殊的**二叉搜索树**。红黑树的每个节点都有“颜色”，可以是红或黑。

红黑树的应用比较广泛，主要是用它来存储**有序**的数据，它的时间复杂度是O(logn)。
例如，Java集合中的[TreeSet](http://www.cnblogs.com/skywang12345/p/3311268.html)和[TreeMap](http://www.cnblogs.com/skywang12345/p/3310928.html)，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。

![img](https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg)



**红黑树的特性**:
（1）根节点是黑色。
（2）每个叶子节点（NIL）是黑色。
（3）如果一个节点是红色的，则它的子节点必须是黑色的。 //红之子、之父必黑
（4）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。//黑深度


这样的特性，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是**相对接近平衡**的二叉树搜索树。比起AVL树的精确平衡，红黑树更好维护。

实际上，红黑树和(2,4)-B树等价：
![img](https://pic1.zhimg.com/v2-6c77fde1dd557e9807bee6092fa3a2e0_b.jpg)

  由等价性，既然B-树是平衡的，那么红黑树自然也是。







